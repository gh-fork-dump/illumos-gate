.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright (c) 2003, Sun Microsystems, Inc. All Rights Reserved
.\" Copyright 2015, Joyent, Inc.
.\"
.Dd March 10, 2015
.Dt MEMINFO 2
.Os
.Sh NAME
.Nm meminfo
.Nd provide information about memory
.Sh SYNOPSIS
.In sys/types.h
.In sys/mman.h
.Ft int
.Fo meminfo
.Fa "const uint64_t inaddr[]"
.Fa "int addr_count"
.Fa "const uint_t info_req[]"
.Fa "int info_count"
.Fa "uint64_t outdata[]"
.Fa "uint_t validity[]"
.Fc
.Sh PARAMETERS
.Bl -tag -width "addr_count"
.It Fa inaddr
An array of input addresses;
the maximum number of addresses that can be processed for each call is
.Dv MAX_MEMINFO_CNT .
.It Fa addr_count
The number of addresses.
.It Fa info_req
An array of types of information requested.
.It Fa info_count
The number of pieces of information requested for each address in
.Fa inaddr .
.It Fa outdata
An array into which results are placed;
array size must be the product of
.Fa info_count
and
.Fa addr_count .
.It Fa validity
An array of size
.Fa addr_count
containing bitwise result codes.
The 0th bit evaluates validity of corresponding input address, the 1st bit
evaluates validity of response to first member of
.Fa info_req ,
and so on.
.El
.Sh DESCRIPTION
The
.Fn meminfo
function provides information about virtual and physical memory particular to
the calling process.
The user or developer of performance utilities can use this information to
analyze system memory allocations and develop a better understanding of the
factors affecting application performance.
.Pp
The caller of
.Fn meminfo
can obtain the following types of information about both virtual and physical
memory.
.Bl -tag -width Ds
.It Dv MEMINFO_VPHYSICAL
The physical address corresponding to the virtual address.
.It Dv MEMINFO_VLGRP
The locality group of physical page corresponding to the virtual address.
.It Dv MEMINFO_VPAGESIZE
The size of physical page corresponding to the virtual address.
.It Dv MEMINFO_VREPLCNT
The number of replicated physical pages corresponding to the specified virtual
address.
.It Dv MEMINFO_VREPL | Fa n
The
.Fa n Ns th
physical replica of the specified virtual address.
.It Dv MEMINFO_VREPL_LGRP | Fa n
The lgrp of
.Fa n Ns th
physical replica of the specified virtual address.
.It Dv MEMINFO_PLGRP
The locality group of the specified physical address
.El
.Pp
All but
.Dv MEMINFO_VLGRP
and
.Dv MEMINFO_VPAGESIZE
require the
.Brq Dv PRIV_PROC_MEMINFO
privilege.
.Sh RETURN VALUES
.Rv -std
.Sh ERRORS
The
.Fn meminfo
function will fail if:
.Bl -tag -width Er
.It Bq Er EFAULT
The area pointed to by
.Fa outdata
or
.Fa validity
could not be written, or the data pointed to by
.Fa info_req
or
.Fa inaddr
could not be read.
.It Bq Er EINVAL
The value of
.Fa info_count
is greater than 31 or less than 1, or the value of
.Fa addr_count
is less than 1.
.El
.Sh EXAMPLES
The following example prints the physical pages and page sizes corresponding to
a set of virtual addresses.
.Bd -literal
void
print_info(void **addrvec, int how_many)
{
    static const uint_t info[] = {
        MEMINFO_VPHYSICAL,
        MEMINFO_VPAGESIZE
    };

    int info_num = sizeof (info) / sizeof (info[0]);
    int i;

    uint64_t *inaddr = alloca(sizeof (uint64_t) * how_many);
    uint64_t *outdata = alloca(sizeof (uint64_t) * how_many * info_num);
    uint_t *validity = alloca(sizeof (uint_t) * how_many);

    for (i = 0; i < how_many; i++)
        inaddr[i] = (uint64_t)addrvec[i];

    if (meminfo(inaddr, how_many, info, info_num, outdata,
                validity) < 0) {
        perror("meminfo");
        return;
    }

    for (i = 0; i < how_many; i++) {
        if ((validity[i] & 1) == 0)
            printf("address 0x%llx not part of address space\en",
                inaddr[i]);

        else if ((validity[i] & 2) == 0)
            printf("address 0x%llx has no physical page "
                "associated with it\en", inaddr[i]);

        else {
            char buff[80];
            if ((validity[i] & 4) == 0)
                strcpy(buff, "<Unknown>");
            else
                sprintf(buff, "%lld",
                    outdata[i * info_num + 1]);

            printf("address 0x%llx is backed by physical "
                "page 0x%llx of size %s\en",
                inaddr[i], outdata[i * info_num], buff);
        }
    }
}
.Ed
.Sh INTERFACE STABILITY
.Sy Stable
.Sh MT-LEVEL
.Sy Async-Signal-Safe
.Sh SEE ALSO
.Xr memcntl 2 ,
.Xr mmap 2 ,
.Xr gethomelgroup 3C ,
.Xr getpagesize 3C ,
.Xr madvise 3C ,
.Xr sysconf 3C ,
.Xr attributes 5 ,
.Xr privileges 5
