.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright (c) 2000, Sun Microsystems, Inc. All Rights Reserved
.\"
.Dd March 8, 2000
.Dt MSGSNAP 2
.Os
.Sh NAME
.Nm msgsnap
.Nd message queue snapshot operation
.Sh SYNOPSIS
.In sys/msg.h
.Ft int
.Fo msgsnap
.Fa "int msqid"
.Fa "void *buf"
.Fa "size_t bufsz"
.Fa "long msgtyp"
.Fc
.Sh DESCRIPTION
The
.Fn msgsnap
function reads all of the messages of type
.Fa msgtyp
from the queue associated with the message queue identifier specified by
.Fa msqid
and places them in the user-defined buffer pointed to by
.Fa buf .
.Pp
The
.Fa buf
argument points to a user-defined buffer that on return will
contain first a buffer header structure:
.Bd -literal
struct msgsnap_head {
	size_t	msgsnap_size;	/* bytes used/required in the buffer */
	size_t	msgsnap_nmsg;	/* number of messages in the buffer */
};
.Ed
.Pp
followed by
.Va msgsnap_nmsg
messages, each of which starts with a message header:
.Bd -literal
struct msgsnap_mhead {
	size_t	msgsnap_mlen;	/* number of bytes in the message */
	long	msgsnap_mtype;	/* message type */
};
.Ed
.Pp
and followed by
.Va msgsnap_mlen
bytes containing the message contents.
.Pp
Each subsequent message header is located at the first byte following the
previous message contents, rounded up to a
.Fn sizeof size_t
boundary.
.Pp
The
.Fa bufsz
argument specifies the size of
.Fa buf
in bytes.
If
.Fa bufsz
is less than
.Fn sizeof msgsnap_head , Fn msgsnap
fails with
.Er EINVAL .
If
.Fa bufsz
is insufficient to contain all of the requested
messages,
.Fn msgsnap
succeeds but returns with
.Va msgsnap_nmsg
set to 0
and with
.Va msgsnap_size
set to the required size of the buffer in bytes.
.Pp
The
.Fa msgtyp
argument specifies the types of messages requested as follows:
.Bl -dash -width Ds
.It
If
.Fa msgtyp
is 0, all of the messages on the queue are read.
.It
If
.Fa msgtyp
is greater than 0, all messages of type
.Fa msgtyp
are read.
.It
If
.Fa msgtyp
is less than 0, all messages with type less than or equal to
the absolute value of
.Fa msgtyp
are read.
.El
.Pp
The
.Fn msgsnap
function is a non-destructive operation.
Upon completion, no changes are made to the data structures associated with
.Fa msqid .
.Sh RETURN VALUES
.Rv -std
.Sh ERRORS
The
.Fn msgsnap
function will fail if:
.Bl -tag -width Er
.It Bq Er EACCES
Operation permission is denied to the calling process.
See
.Xr Intro 2 .
.It Bq Er EINVAL
The
.Fa msqid
argument is not a valid message queue identifier or the value of
.Fa bufsz
is less than
.Fn sizeof "struct msgsnap_head" .
.It Bq Er EFAULT
The
.Fa buf
argument points to an illegal address.
.El
.Sh USAGE
The
.Fn msgsnap
function returns a snapshot of messages on a message queue at one point in
time.
The queue contents can change immediately following return from
.Fn msgsnap .
.Sh EXAMPLES
This is sample C code indicating how to use the msgsnap function
.Pq see Xr msgids 2
.Bd -literal
void
process_msgid(int msqid)
{
    size_t bufsize;
    struct msgsnap_head *buf;
    struct msgsnap_mhead *mhead;
    int i;

    /* allocate a minimum-size buffer */
    buf = malloc(bufsize = sizeof(struct msgsnap_head));

    /* read all of the messages from the queue */
    for (;;) {
        if (msgsnap(msqid, buf, bufsize, 0) != 0) {
            perror("msgsnap");
            free(buf);
            return;
        }
        if (bufsize >= buf->msgsnap_size)  /* we got them all */
            break;
        /* we need a bigger buffer */
        buf = realloc(buf, bufsize = buf->msgsnap_size);
    }

    /* process each message in the queue (there may be none) */
    mhead = (struct msgsnap_mhead *)(buf + 1);  /* first message */
    for (i = 0; i < buf->msgsnap_nmsg; i++) {
        size_t mlen = mhead->msgsnap_mlen;

        /* process the message contents */
        process_message(mhead->msgsnap_mtype, (char *)(mhead+1), mlen);

        /* advance to the next message header */
        mhead = (struct msgsnap_mhead *)
            ((char *)mhead + sizeof(struct msgsnap_mhead) +
            ((mlen + sizeof(size_t) - 1) & ~(sizeof(size_t) - 1)));
    }

    free(buf);
}
.Ed
.Sh MT-LEVEL
.Sy Async-Signal-Safe
.Sh SEE ALSO
.Xr ipcrm 1 ,
.Xr ipcs 1 ,
.Xr Intro 2 ,
.Xr msgctl 2 ,
.Xr msgget 2 ,
.Xr msgids 2 ,
.Xr msgrcv 2 ,
.Xr msgsnd 2 ,
.Xr attributes 5
