.\"
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for
.\" permission to reproduce portions of its copyrighted documentation.
.\" Original documentation from The Open Group can be obtained online at
.\" http://www.opengroup.org/bookstore/.
.\"
.\" The Institute of Electrical and Electronics Engineers and The Open
.\" Group, have given us permission to reprint portions of their
.\" documentation.
.\"
.\" In the following statement, the phrase ``this text'' refers to portions
.\" of the system documentation.
.\"
.\" Portions of this text are reprinted and reproduced in electronic form
.\" in the SunOS Reference Manual, from IEEE Std 1003.1, 2004 Edition,
.\" Standard for Information Technology -- Portable Operating System
.\" Interface (POSIX), The Open Group Base Specifications Issue 6,
.\" Copyright (C) 2001-2004 by the Institute of Electrical and Electronics
.\" Engineers, Inc and The Open Group.  In the event of any discrepancy
.\" between these versions and the original IEEE and The Open Group
.\" Standard, the original IEEE and The Open Group Standard is the referee
.\" document.  The original Standard can be obtained online at
.\" http://www.opengroup.org/unix/online.html.
.\"
.\" This notice shall appear on any product containing this material.
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1992, X/Open Company Limited.  All Rights Reserved.
.\" Copyright (c) 2007, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright (c) 2013, OmniTI Computer Consulting, Inc. All rights reserved.
.\" Copyright 2015 Joyent, Inc.
.\"
.Dd February 16, 2015
.Dt FCNTL 2
.Os
.Sh NAME
.Nm fcntl
.Nd file control
.Sh SYNOPSIS
.In sys/types.h
.In unistd.h
.In fcntl.h
.Ft int
.Fo fcntl
.Fa "int fildes"
.Fa "int cmd"
.Fa "/* arg */ ..."
.Fc
.Sh DESCRIPTION
The
.Fn fcntl
function provides for control over open files.
The
.Fa fildes
argument is an open file descriptor.
.Pp
The
.Fn fcntl
function can take a third argument,
.Fa arg ,
whose data type, value and use depend upon the value of
.Fa cmd .
The
.Fa cmd
argument specifies the operation to be performed by
.Fn fcntl .
.Pp
The values for
.Fa cmd
are defined in
.In fcntl.h
and include:
.Bl -tag -width Ds
.It Dv F_DUPFD
Return a new file descriptor which is the lowest numbered available (that is,
not already open) file descriptor greater than or equal to the third argument,
.Fa arg ,
taken as an integer of type
.Vt int .
The new file descriptor
refers to the same open file description as the original file descriptor, and
shares any locks.
The
.Dv FD_CLOEXEC
flag associated with the new file
descriptor is cleared to keep the file open across calls to one of the
.Xr exec 2
functions.
.It Dv F_DUP2FD
Similar to
.Dv F_DUPFD ,
but always returns
.Fa arg . Dv F_DUP2FD
closes
.Fa arg
if it is open and not equal to
.Fa fildes . Dv F_DUP2FD
is equivalent to
.Fn dup2 fildes arg .
.It Dv F_DUPFD_CLOEXEC
Similar to
.Dv F_DUPFD
except that instead of clearing
.Dv FD_CLOEXEC
it is explicitly set on the returned file descriptor.
.It Dv F_DUP2FD_CLOEXEC
Similar to
.Dv F_DUP2FD
with two exceptions.
The
.Dv FD_CLOEXEC
flag is explicitly set on the returned file descriptor.
If
.Fa fildes
equals
.Fa arg ,
the call will fail setting
.Va errno
to
.Er EINVAL .
.It Dv F_FREESP
Free storage space associated with a section of the ordinary file
.Fa fildes .
The section is specified by a variable of data type
.Vt struct flock
pointed to by
.Fa arg .
The data type
.Vt struct flock
is defined in the
.In fcntl.h header Pq see Xr fcntl.h 3HEAD
and is described below.
Note that all file systems might not support all possible variations of
.Dv F_FREESP
arguments.
In particular, many file systems allow space to be freed only at the end of a
file.
.It Dv F_FREESP64
Equivalent to
.Dv F_FREESP ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
.It Dv F_ALLOCSP
Allocate space for a section of the ordinary file
.Fa fildes .
The section is specified by a variable of data type
.Vt struct flock
pointed to by
.Fa arg .
The data type
.Vt struct flock
is defined in the
.In fcntl.h header Pq see Xr fcntl.h 3HEAD
and is described below.
.It Dv F_ALLOCSP64
Equivalent to
.Dv F_ALLOCSP ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
.It Dv F_GETFD
Get the file descriptor flags defined in
.In fcntl.h
that are associated with the file descriptor
.Fa fildes .
File descriptor flags are associated with a single file descriptor and do not
affect other file descriptors that refer to the same file.
.It Dv F_GETFL
Get the file status flags and file access modes, defined in
.In fcntl.h ,
for the file descriptor specified by
.Fa fildes .
The file access modes can be extracted from the return value using the mask
.Dv O_ACCMODE ,
which is defined in
.In fcntl.h .
File status flags and file access modes do not affect other file descriptors
that refer to the same file with different open file descriptions.
.It Dv F_GETOWN
If
.Fa fildes
refers to a socket, get the process or process group ID
specified to receive
.Dv SIGURG
signals when out-of-band data is available.
Positive values indicate a process ID; negative values, other than -1, indicate
a process group ID.
If
.Fa fildes
does not refer to a socket, the results are unspecified.
.It Dv F_GETXFL
Get the file status flags, file access modes, and file creation and assignment
flags, defined in
.In fcntl.h ,
for the file descriptor specified by
.Fa fildes .
The file access modes can be extracted from the return value using the mask
.Dv O_ACCMODE ,
which is defined in
.In fcntl.h .
File status flags, file access modes, and file creation and assignment flags do
not affect other file descriptors that refer to the same file with different
open file descriptions.
.It Dv F_SETFD
Set the file descriptor flags defined in
.In fcntl.h ,
that are associated with
.Fa fildes ,
to the third argument,
.Fa arg ,
taken as type
.Vt int .
If the
.Dv FD_CLOEXEC
flag in the third argument is 0, the file will remain open across the
.Xr exec 2
functions; otherwise the file will be closed upon successful execution of one
of the
.Xr exec 2
functions.
.It Dv F_SETFL
Set the file status flags, defined in
.In fcntl.h ,
for the file descriptor specified by
.Fa fildes
from the corresponding bits in the
.Fa arg
argument, taken as type
.Vt int .
Bits corresponding to the file access mode and file creation and assignment
flags that are set in
.Fa arg
are ignored.
If any bits in
.Fa arg
other than those mentioned here are changed by the application, the result is
unspecified.
.It Dv F_SETOWN
If
.Fa fildes
refers to a socket, set the process or process group ID specified to receive
.Dv SIGURG
signals when out-of-band data is available, using the value of the third
argument,
.Fa arg ,
taken as type
.Dv int .
Positive values indicate a process ID; negative values, other than -1, indicate
a process group ID.
If
.Fa fildes
does not refer to a socket, the results are unspecified.
.El
.Pp
The following commands are available for POSIX advisory or mandatory record
locking.
POSIX record locking is supported for regular files, and may be supported for
other files.
See
.Sx FILE LOCKING
for information about the types of file locks available and their interaction.
.Bl -tag -width Ds
.It Dv F_GETLK
Get the first lock which blocks the POSIX lock description pointed to by the
third argument,
.Fa arg ,
taken as a pointer to type
.Vt struct flock ,
defined in
.In fcntl.h .
The information retrieved overwrites the information passed to
.Fn fcntl
in the structure
.Vt flock .
If no lock is found that would prevent this lock from being created, then the
structure will be left unchanged except for the lock type which will be set to
.Dv F_UNLCK .
If multiple locks exist that would prevent this lock from being created, which
one is returned is unspecified.
If the blocking lock is an OFD-style lock, -1 will be returned for the lock's
pid value.
.It Dv F_GETLK64
Equivalent to
.Dv F_GETLK ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
.It Dv F_SETLK
Set or clear a POSIX record lock according to the lock description pointed to
by the third argument,
.Fa arg ,
taken as a pointer to type
.Vt struct flock ,
defined in
.In fcntl.h .
.Dv F_SETLK
is used to establish shared (or read) locks
.Pq Dv F_RDLCK
or exclusive (or write) locks
.Pq Dv F_WRLCK ,
as well as to remove either type of lock
.Pq Dv F_UNLCK .
.Dv F_RDLCK , F_WRLCK
and
.Dv F_UNLCK
are defined in
.In fcntl.h .
If a shared or exclusive lock cannot be set,
.Fn fcntl
will return immediately with a return value of -1.
.It Dv F_SETLK64
Equivalent to
.Dv F_SETLK ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
.It Dv F_SETLKW
This command is the same as
.Dv F_SETLK
except that if a shared or exclusive lock is blocked by other locks, the
process will wait until the request can be satisfied.
If a signal that is to be caught is received while
.Fn fcntl
is waiting for a region,
.Fn fcntl
will be interrupted.
Upon return from the process' signal handler,
.Fn fcntl
will return -1 with
.Va errno
set to
.Er EINTR ,
and the lock operation will not be done.
.It Dv F_SETLKW64
Equivalent to
.Dv F_SETLKW ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
.El
.Pp
The following commands are available for OFD (open file description) advisory
record locking.
OFD record locking is supported for regular files, and may be supported for
other files.
See
.Sx FILE LOCKING
for information about the types of file locks available and their interaction.
OFD-style record locks are currently limited to spanning the entire file and
these locks are currently not supported over remote file systems
.Pq e.g. Xr nfs 4
which use the Network Lock Manager.
.Bl -tag -width Ds
.It Dv F_OFD_GETLK
Get the first lock which blocks the OFD lock description pointed to by the
third argument,
.Fa arg ,
taken as a pointer to type
.Vt struct flock ,
defined in
.In fcntl.h .
The information retrieved overwrites the information passed to
.Fn fcntl
in the structure
.Vt flock .
If no lock is
found that would prevent this lock from being created, then the structure will
be left unchanged except for the lock type which will be set to
.Dv F_UNLCK .
If multiple locks exist that would prevent this lock from being created, which
one is returned is unspecified.
If the blocking lock is an OFD-style lock, -1 will be returned for the lock's
pid value.
.It Dv F_OFD_GETLK64
Equivalent to
.Dv F_OFD_GETLK ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
This command exists solely to allow the use of OFD locks with the transitional
64-bit file interfaces.
.It Dv F_OFD_SETLK
Set or clear a OFD record lock according to the lock description pointed to
by the third argument,
.Fa arg ,
taken as a pointer to type
.Vt struct flock ,
defined in
.In fcntl.h .
.Dv F_OFD_SETLK
is used to establish
shared (or read) locks
.Pq Dv F_RDLCK
or exclusive (or write) locks
.Pq Dv F_WRLCK ,
as well as to remove either type of lock
.Pq Dv F_UNLCK .
.Dv F_RDLCK , F_WRLCK
and
.Dv F_UNLCK
are defined in
.In fcntl.h .
If a shared or exclusive lock cannot be set,
.Fn fcntl
will return immediately with a return value of -1.
.It Dv F_OFD_SETLK64
Equivalent to
.Dv F_OFD_SETLK ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
This command exists solely to allow the use of OFD locks with the transitional
64-bit file interfaces.
.It Dv F_OFD_SETLKW
This command is the same as
.Dv F_OFD_SETLK
except that if a shared or exclusive lock is blocked by other locks, the
process will wait until the request can be satisfied.
If a signal that is to be caught is received while
.Fn fcntl
is waiting for a region,
.Fn fcntl
will be interrupted.
Upon return from the process' signal handler,
.Fn fcntl
will return -1 with
.Va errno
set to
.Er EINTR ,
and the lock operation will not be done.
.It Dv F_OFD_SETLKW64
Equivalent to
.Dv F_OFD_SETLKW ,
but takes a
.Vt struct flock64
argument rather than a
.Vt struct flock
argument.
See
.Xr lf64 5 .
This command exists solely to allow the use of OFD locks with the transitional
64-bit file interfaces.
.El
.Pp
The following values for
.Fa cmd
are used for file share reservations.
A share reservation is placed on an entire file to allow cooperating processes
to control access to the file.
See
.Sx SHARE RESERVATIONS
for additional information.
.Pp
.Bl -tag -compact -width "F_UNSHARE"
.It Dv F_SHARE
Sets a share reservation on a file with the specified access mode and
designates which types of access to deny.
.It Dv F_UNSHARE
Remove an existing share reservation.
.El
.Sh FILE LOCKING
Two types of file locks are supported: POSIX-style and OFD-style.
OFD-style locks are associated with the open file description (not descriptor)
instead of with a process.
Either type is advisory by default, but POSIX-style locks can be mandatory if,
and only if, mandatory locking has been enabled on the file being locked.
Each type of lock may be created through two different interfaces.
POSIX-style locks are created via the
.Dv F_SETLK , F_SETLK64 , F_SETLKW
or
.Dv F_SETLKW64
commands to this system call or by use of the
.Xr lockf 3C
routine.
There is no difference between locks created via one mechanism or the other.
Likewise, OFD-style locks are created via the
.Dv F_OFD_SETLK , F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64
commands to this system call or by use of the Linux/BSD-compatible
.Xr flock 3C
routine.
Note that this system call supports the creation of range-specified OFD-style
file locks, while
.Xr flock 3C
does not.
However, the current implementation of OFD-style locking is limited to locking
the entire file.
This limitation might be removed in the future.
.Pp
The essential distinction between POSIX-style locks and OFD-style locks lie
in how ownership of a lock is scoped.
POSIX locks are scoped to a process.
All
POSIX locks associated with a file for a given process are removed when any
file descriptor for that file is closed by that process or the process holding
that file descriptor terminates.
POSIX-style locks are not inherited by a child
process created using
.Xr fork 2 .
An OFD-style lock is scoped to the file description for a file, not the process
or open file descriptor.
Thus all file descriptors referring to the same description
.Po i.e. those created via the
.Dv F_DUPFD , F_DUP2FD , F_DUPFD_CLOEXEC
or
.Dv F_DUP2FD_CLOEXEC
commands to the
.Xr fcntl 2
system call, or those created via the
.Xr dup 2
system call, or those inherited by a child process created via
.Xr fork 2 Pc
reference the same lock, but a file descriptor obtained via a separate
.Xr open 2
call on the same file will reference a different lock.
A lock is removed only on the last
.Xr close 2
of the description, or when the lock is explicitly unlocked.
.Pp
Locks of both styles are compatible.
A file that has been locked with one style of lock will be regarded as locked
when creation of a lock of either style is attempted, and information about the
lock will be provided via any of the
.Dv F_GETLK , F_GETLK64 , F_OFD_GETLK
or
.Dv F_OFD_GETLK64
commands to this system call if that lock would conflict with an attempt to
create the specified lock regardless of whether the specified lock is of the
same style as the conflicting extant lock.
Because ownership of OFD-style locks is scoped to the open description rather
than the calling process, the
.Va l_pid
field of a lock descriptor for any such lock will always be set to -1.
.Pp
When a shared lock is set on a segment of a file, other callers (regardless
of whether in the same or different process and of whether referenced via the
same open file) will be able to set shared locks on that segment or a portion
of it.
A POSIX-style shared lock prevents any other process from setting an exclusive
lock on any portion of the protected area.
A OFD-style shared lock prevents any caller (even callers in the same process)
from setting an exclusive lock on any portion of the protected area, unless the
caller makes the request against a file descriptor referencing the same open
file against which the shared lock was created, in which case the lock will be
downgraded to a shared lock with respect to the specified region.
A request for a shared lock of either style will fail if the file descriptor
was not opened with read access.
.Pp
A POSIX-style exclusive lock will prevent any other process from setting a
shared lock or an exclusive lock (of either style) on any portion of the
protected area.
A request for an exclusive lock will fail if the file descriptor was not opened
with write access.
.Pp
The flock structure contains at least the following elements:
.Bd -literal -offset indent
short   l_type;   /* lock operation type */
short   l_whence; /* lock base indicator */
off_t   l_start;  /* starting offset from base */
off_t   l_len;    /* lock length; l_len == 0 means
                     until end of file */
int     l_sysid;  /* system ID running process holding lock */
pid_t   l_pid;    /* process ID of process holding lock */
.Ed
.Pp
The value of
.Va l_whence
is
.Dv SEEK_SET , SEEK_CUR
or
.Dv SEEK_END ,
to indicate that the relative offset
.Va l_start
bytes will be measured from the start of the file, current position or end of
the file, respectively.
The value of
.Va l_len
is the number of consecutive bytes to be locked.
The value of
.Va l_len
may be negative
.Po where the definition of
.Vt off_t
permits negative values of
.Va l_len Pc .
After a successful
.Dv F_GETLK , F_GETLK64 , F_OFD_GETLK
or
.Dv F_OFD_GETLK64
request, that is, one in which a lock was found, the value of
.Va l_whence
will be
.Dv SEEK_SET .
.Pp
The
.Va l_pid
and
.Va l_sysid
fields are used only with
.Dv F_GETLK
or
.Dv F_GETLK64
to return the process ID of the process holding a POSIX-style blocking lock and
to indicate which system is running that process, or -1 if it is an OFD-style
lock.
These fields must both be initialized to 0 prior to issuing a OFD-style locking
command
.Po Dv F_OFD_GETLK
or
.Dv F_OFD_GETLK64 Pc .
.Pp
If
.Va l_len
is positive, the area affected starts at
.Va l_start
and ends
at
.Ql l_start\ +\ l_len\ -\ 1 .
If
.Va l_len
is negative, the area
affected starts at
.Ql l_start\ +\ l_len
and ends at
.Ql l_start\ -\ 1 .
Locks may start and extend beyond the current end of a file, but must not be
negative relative to the beginning of the file.
A lock will be set to extend to the largest possible value of the file offset
for that file by setting
.Va l_len
to 0.
If such a lock also has
.Va l_start
set to 0 and
.Va l_whence
is set to
.Dv SEEK_SET ,
the whole file will be locked.
.Pp
If a lock exists for which
.Va l_len
is 0 and which includes the last byte of the requested segment, and an unlock
.Pq Dv F_UNLCK
request is made in which
.Va l_len
is non-zero and the offset of the last byte of the requested segment is the
maximum value for an object of type
.Vt off_t ,
then the
.Dv F_UNLCK
request will be treated as a request to unlock from the start of the requested
segment with an
.Va l_len
equal to 0.
Otherwise, the request will attempt to unlock only the requested segment.
.Pp
There will be at most one type of lock set for each byte in the
file.
Before a successful return from an
.Dv F_SETLK , F_SETLK64 , F_SETLKW
or
.Dv F_SETLKW64
request when the calling process has previously existing POSIX-style locks on
bytes in the region specified by the request, the previous POSIX-style lock
type for each byte in the specified region will be replaced by the new lock
type.
As specified above under the descriptions of shared locks and exclusive locks,
an
.Dv F_SETLK , F_SETLK64 , F_SETLKW
or
.Dv F_SETLKW64
request will (respectively) fail or block when locks exist on bytes in the
specified region and the type of any of those locks conflicts with the type
specified in the request.
.Pp
Similarly, before a successful return from an
.Dv F_OFD_SETLK , F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64
request when previously-created OFD-style locks associated with the open file
apply to bytes in the region specified by the request, the previous OFD-style
lock type for each byte in the specified region will be replaced by the new
lock type.
As specified above under the descriptions of shared locks and exclusive locks,
an
.Dv F_OFD_SETLK , F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64
request will (respectively) fail or block when locks exist on bytes in the
specified region and the type of any of those locks conflicts with the type
specified in the request.
.Pp
A potential for deadlock occurs if a process controlling a locked region is put
to sleep by attempting to lock another process' locked region.
If the system detects that sleeping until a locked region is unlocked would
cause a deadlock,
.Fn fcntl
will fail with an
.Er EDEADLK
error.
This deadlock detection and error value apply only to POSIX-style locks.
No deadlock detection is performed when attempting to set an OFD-style lock.
.Sh SHARE RESERVATIONS
File share reservations are an advisory form of access control among
cooperating processes, on both local and remote machines.
They are most often used by DOS or Windows emulators and DOS based NFS clients.
However, native UNIX versions of DOS or Windows applications may also
choose to use this form of access control.
.Pp
A share reservation is described by an
.Vt fshare
structure defined in
.In sys/fcntl.h ,
which is included in
.In fcntl.h
as follows:
.Bd -literal -offset indent
typedef struct fshare {
    short   f_access;
    short   f_deny;
    int     f_id;
} fshare_t;
.Ed
.Pp
A share reservation specifies the type of access,
.Va f_access ,
to be
requested on the open file descriptor.
If access is granted, it further specifies what type of access to deny other
processes,
.Va f_deny .
A single process on the same file may hold multiple non-conflicting
reservations by specifying an identifier,
.Va f_id ,
unique to the process, with each request.
.Pp
An
.Dv F_UNSHARE
request releases the reservation with the specified
.Va f_id .
The
.Va f_access
and
.Va f_deny
fields are ignored.
.Pp
Valid
.Va f_access
values are:
.Pp
.Bl -tag -compact -width "F_COMPAT"
.It Dv F_RDACC
Set a file share reservation for read-only access.
.It Dv F_WRACC
Set a file share reservation for write-only access.
.It Dv F_RWACC
Set a file share reservation for read and write access.
.El
.Pp
Valid
.Va f_deny
values are:
.Pp
.Bl -tag -compact -width "F_COMPAT"
.It Dv F_COMPAT
Set a file share reservation to compatibility mode.
.It Dv F_RDDNY
Set a file share reservation to deny read access to other processes.
.It Dv F_WRDNY
Set a file share reservation to deny write access to other processes.
.It Dv F_RWDNY
Set a file share reservation to deny read and write access to other processes.
.It Dv F_NODNY
Do not deny read or write access to any other process.
.El
.Sh RETURN VALUES
Upon successful completion, the value returned depends on
.Va cmd
as follows:
.Pp
.Bl -tag -compact -width "F_OFD_GETLKW64"
.It Dv F_DUPFD
A new file descriptor.
.It Dv F_FREESP
Value of 0.
.It Dv F_GETFD
Value of flags defined in
.In fcntl.h .
The return value will not be negative.
.It Dv F_GETFL
Value of file status flags and access modes.
The return value will not be negative.
.It Dv F_GETOWN
Value of the socket owner process or process group; this will not be -1.
.It Dv F_GETXFL
Value of file status flags, access modes, and creation and assignment flags.
The return value will not be negative.
.It Dv F_GETLK
.It Dv F_GETLK64
.It Dv F_OFD_GETLK
.It Dv F_OFD_GETLK64
.It Dv F_OFD_SETLK
.It Dv F_OFD_SETLK64
.It Dv F_OFD_SETLKW
.It Dv F_OFD_SETLKW64
.It Dv F_SETFD
.It Dv F_SETFL
.It Dv F_SETLK
.It Dv F_SETLK64
.It Dv F_SETLKW
.It Dv F_SETLKW64
.It Dv F_SETOWN
.It Dv F_SHARE
.It Dv F_UNSHARE
Value other than -1.
.El
.Pp
Otherwise the value -1 is returned and the global variable
.Va errno
is set to indicate the error.
.Sh ERRORS
The
.Fn fcntl
function will fail if:
.Bl -tag -width Er
.It Er EAGAIN
The
.Fa cmd
argument is
.Dv F_SETLK , F_SETLK64 , F_OFD_SETLK
or
.Dv F_OFD_SETLK64 ,
the type of lock
.Pq Va l_type
is a shared
.Pq Dv F_RDLCK
or exclusive
.Pq Dv F_WRLCK
lock, and the segment of a file to be locked is already exclusive-locked by
another process or open file; or the type is an exclusive lock and some portion
of the segment of a file to be locked is already shared-locked or
exclusive-locked by another process or open file.
.Pp
The
.Fa cmd
argument is
.Dv F_FREESP ,
the file exists, mandatory file/record locking is set, and there are
outstanding record locks on the file; or the
.Fa cmd
argument is
.Dv F_SETLK , F_SETLK64 , F_SETLKW
or
.Dv F_SETLKW64 ,
mandatory file/record locking is set, and the file is currently being mapped to
virtual memory using
.Xr mmap 2 .
.Pp
The
.Fa cmd
argument is
.Dv F_SHARE
and
.Fa f_access
conflicts with an existing
.Va f_deny
share reservation.
.It Er EBADF
The
.Fa fildes
argument is not a valid open file descriptor; or the
.Fa cmd
argument is
.Dv F_SETLK , F_SETLK64 , F_SETLKW , F_SETLKW64 , F_OFD_SETLK , \
.Dv F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64 ,
the type of lock,
.Pq Va l_type ,
is a shared lock
.Pq Dv F_RDLCK ,
and
.Dv fildes
is not a valid file descriptor open for reading; or the type of lock is an
exclusive lock
.Pq Dv F_WRLCK
and
.Fa fildes
is not a valid file descriptor open for writing.
.Pp
The
.Fa cmd
argument is
.Dv F_FREESP
and
.Fa fildes
is not a valid file descriptor open for writing.
.Pp
The
.Fa cmd
argument is
.Dv F_DUP2FD ,
and
.Fa arg
is negative or is not less than the current resource limit for
.Dv RLIMIT_NOFILE .
.Pp
The
.Fa cmd
argument is
.Dv F_SHARE ,
the
.Va f_access
share reservation is for write access, and
.Fa fildes
is not a valid file descriptor open for writing.
.Pp
The
.Fa cmd
argument is
.Dv F_SHARE ,
the
.Va f_access
share reservation is for read access, and
.Fa fildes
is not a valid file descriptor open for reading.
.It Er EFAULT
The
.Fa cmd
argument is
.Dv F_GETLK , F_GETLK64 , F_SETLK , F_SETLK64 , F_SETLKW , F_SETLKW64 , \
F_OFD_GETLK , F_OFD_GETLK64 , F_OFD_SETLK , F_OFD_SETLK64 , F_OFD_SETLKW , \
F_OFD_SETLKW64 , F_SHARE , F_UNSHARE
or
.Dv F_FREESP
and the
.Fa arg
argument points to an illegal address.
.It Er EINTR
The
.Fa cmd
argument is
.Dv F_SETLKW , F_SETLKW64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64 ,
and the function was interrupted by a signal.
.It Er EINVAL
The
.Fa cmd
argument is invalid or not supported by the file system; or the
.Fa cmd
argument is
.Dv F_DUPFD
and
.Fa arg
is negative or greater than or equal to
.Dv OPEN_MAX ;
or the
.Fa cmd
argument is
.Dv F_GETLK , F_GETLK64 , F_SETLK , F_SETLK64 , F_SETLKW , F_SETLKW64 , \
F_OFD_GETLK , F_OFD_GETLK64 , F_OFD_SETLK , F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64 ,
and the data pointed to by
.Fa arg
is not valid; or
.Fa fildes
refers to a file that does not support locking.
.Pp
The
.Fa cmd
argument is
.Dv F_UNSHARE
and a reservation with this
.Va f_id
for this process does not exist.
.Pp
The
.Fa cmd
argument is
.Dv F_DUP2FD_CLOEXEC
and
.Fa fildes
is equal to
.Fa arg .
.It Er EIO
An I/O error occurred while reading from or writing to the file system.
.It Er EMFILE
The
.Fa cmd
argument is
.Dv F_DUPFD
and either
.Dv OPEN_MAX
file descriptors are currently open in the calling process, or no file
descriptors greater than or equal to
.Fa arg
are available.
.It Er ENOLCK
The
.Fa cmd
argument is
.Dv F_SETLK , F_SETLK64 , F_SETLKW , F_SETLKW64 , F_OFD_SETLK , \
F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64 ,
and satisfying the lock or unlock request would result in the number of locked
regions in the system exceeding a system-imposed limit.
.It Er ENOLINK
Either the
.Fa fildes
argument is on a remote machine and the link to that machine is no longer
active; or the
.Fa cmd
argument is
.Dv F_FREESP ,
the file is on a remote machine, and the link to that machine is no longer
active.
.It Er EOVERFLOW
One of the values to be returned cannot be represented correctly.
.Pp
The
.Fa cmd
argument is
.Dv F_GETLK , F_SETLK , F_SETLKW , F_OFD_GETLK , F_OFD_SETLK
or
.Dv F_OFD_SETLKW ,
and the smallest or, if
.Va l_len
is non-zero, the largest, offset of any byte in the requested segment cannot be
represented correctly in an object of type
.Vt off_t .
.Pp
The
.Fa cmd
argument is
.Dv F_GETLK64 , F_SETLK64 , F_SETLKW64 , F_OFD_GETLK64 , F_OFD_SETLK64
or
.Dv F_OFD_SETLKW64 ,
and the smallest or, if
.Va l_len
is non-zero, the largest, offset of any byte in the requested segment cannot be
represented correctly in an object of type
.Vt off64_t .
.El
.Pp
The
.Fn fcntl
function may fail if:
.Bl -tag -width Er
.It Er EAGAIN
The
.Fa cmd
argument is
.Dv F_SETLK , F_SETLK64 , F_SETLKW , F_SETLKW64 , F_OFD_SETLK , \
F_OFD_SETLK64 , F_OFD_SETLKW
or
.Dv F_OFD_SETLKW64
and the file is currently being mapped to virtual memory using
.Xr mmap 2 .
.It Er EDEADLK
The
.Fa cmd
argument is
.Dv F_SETLKW
or
.Dv F_SETLKW64 ,
the lock is blocked by some lock from another process and putting the calling
process to sleep, waiting for that lock to become free would cause a deadlock.
.Pp
The
.Fa cmd
argument is
.Dv F_FREESP ,
mandatory record locking is enabled,
.Dv O_NDELAY
and
.Dv O_NONBLOCK
are clear and a deadlock condition was detected.
.El
.Sh INTERFACE STABILITY
.Sy Standard
.Sh MT-LEVEL
.Sy Async-Signal-Safe
.Sh SEE ALSO
.Xr lockd 1M ,
.Xr chmod 2 ,
.Xr close 2 ,
.Xr creat 2 ,
.Xr dup 2 ,
.Xr exec 2 ,
.Xr fork 2 ,
.Xr mmap 2 ,
.Xr open 2 ,
.Xr pipe 2 ,
.Xr read 2 ,
.Xr sigaction 2 ,
.Xr write 2 ,
.Xr dup2 3C ,
.Xr flock 3C ,
.Xr lockf 3C ,
.Xr fcntl.h 3HEAD ,
.Xr attributes 5 ,
.Xr lf64 5 ,
.Xr standards 5
.Rs
.%T Programming Interfaces Guide
.Re
.Sh NOTES
In the past,
.Va errno
was set to
.Er EACCES
rather than
.Er EAGAIN
when a section of a file is already locked by another process.
Therefore, portable application programs should expect and test for either
value.
.Pp
Advisory locks allow cooperating processes to perform consistent operations on
files, but do not guarantee exclusive access.
Files can be accessed without advisory locks, but inconsistencies may result.
The network share locking protocol does not support the
.Va f_deny
value of
.Dv F_COMPAT .
For network file systems, if
.Va f_access
is
.Dv F_RDACC , Fa f_deny
is mapped to
.Dv F_RDDNY .
Otherwise, it is mapped to
.Dv F_RWDNY .
.Pp
To prevent possible file corruption, the system may reject
.Fn mmap
requests for advisory locked files, or it may reject advisory locking requests
for mapped files.
Applications that require a file be both locked and mapped
should lock the entire file
.Po Va l_start
and
.Va l_len
both set to 0
.Pc .
If a file is mapped, the system may reject an unlock request, resulting in a
lock that does not cover the entire file.
.Pp
The process ID returned for locked files on network file systems might not be
meaningful.
.Pp
If the file server crashes and has to be rebooted, the lock manager
.Pq see Xr lockd 1M
attempts to recover all locks that were associated with that server.
If a lock cannot be reclaimed, the process that held the lock is issued a
.Er SIGLOST
signal.
