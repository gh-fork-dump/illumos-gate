.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright (c) 2007, Sun Microsystems, Inc. All Rights Reserved
.\"
.Dd January 31, 2007
.Dt SETRCTL 2
.Os
.Sh NAME
.Nm setrctl , getrctl
.Nd set or get resource control values
.Sh SYNOPSIS
.In rctl.h
.Ft int
.Fo setrctl
.Fa "const char *controlname"
.Fa "rctlblk_t *old_blk"
.Fa "rctlblk_t *new_blk"
.Fa "uint_t flags"
.Fc
.Ft int
.Fo getrctl
.Fa "const char *controlname"
.Fa "rctlblk_t *old_blk"
.Fa "rctlblk_t *new_blk"
.Fa "uint_t flags"
.Fc
.Sh DESCRIPTION
The
.Fn setrctl
and
.Fn getrctl
functions provide interfaces for the modification and retrieval of resource
control (rctl) values on active entities on the system, such as processes,
tasks, or projects.
All resource controls are unsigned 64-bit integers; however, a collection of
flags are defined that modify which rctl value is to be set or retrieved.
.Pp
Resource controls are restricted to three levels: basic controls that can be
modified by the owner of the calling process, privileged controls that can be
modified only by privileged callers, and system controls that are fixed for the
duration of the operating system instance.
Setting or retrieving each of these
controls is performed by setting the privilege field of the resource control
block to
.Dv RCTL_BASIC , RCTL_PRIVILEGED
or
.Dv RCTL_SYSTEM
with
.Fn rctlblk_set_privilege Pq see Xr rctlblk_set_value 3C .
.Pp
For limits on collective entities such as the task or project, the process ID
of the calling process is associated with the resource control value.
This ID is available by using
.Fn rctlblk_get_recipient_pid Pq see Xr rctlblk_set_value 3C .
These values are visible only to that process and privileged processes within
the collective.
.Pp
The
.Fn getrctl
function provides a mechanism for iterating through all of the established
values on a resource control.
The iteration is primed by calling
.Fn getrctl
with
.Fa old_blk
set to
.Dv NULL ,
a valid resource control block pointer in
.Dv new_blk ,
and specifying
.Dv RCTL_FIRST
in the
.Dv flags
argument.
Once a resource control block has been obtained, repeated calls to
.Fn getrctl
with
.Dv RCTL_NEXT
in the
.Fa flags
argument and the obtained control in the
.Fa old_blk
argument will return the next resource control block in the sequence.
The iteration reports the end of the sequence by failing and setting errno to
.Dv ENOENT .
.Pp
The
.Fn getrctl
function allows the calling process to get the current usage of a controlled
resource using
.Dv RCTL_USAGE
as the
.Fa flags
value.
The current value of the resource usage is placed in the value field of the
resource control block specified by
.Fa new_blk .
This value is obtained with
.Xr rctlblk_set_value 3C .
All other members of the returned block are undefined and might be invalid.
.Pp
The
.Fn setrctl
function allows the creation, modification, or deletion of action-value pairs
on a given resource control.
When passed
.Dv RCTL_INSERT
as the
.Fa flags
value,
.Fn setrctl
expects
.Fa new_blk
to contain a
new action-value pair for insertion into the sequence.
For
.Dv RCTL_DELETE ,
the block indicated by
.Fa new_blk
is deleted from the sequence.
For
.Dv RCTL_REPLACE ,
the block matching
.Fa old_blk
is deleted and replaced by
the block indicated by
.Fa new_blk .
When
.Ql (flags\ &\ RCTL_USE_RECIPIENT_PID)
is non-zero,
.Fn setrctl
uses the process ID set by
.Xr rctlblk_set_value 3C
when selecting the rctl value to insert, delete, or replace basic rctls.
Otherwise, the process ID of the calling process is used.
.Pp
The kernel maintains a history of which resource control values have triggered
for a particular entity, retrievable from a resource control block with the
.Xr rctlblk_set_value 3C
function.
The insertion or deletion of a resource control value at or below the currently
enforced value might cause the currently enforced value to be reset.
In the case of insertion, the newly
inserted value becomes the actively enforced value.
All higher values that have previously triggered will have their firing times
zeroed.
In the case of deletion of the currently enforced value, the next higher value
becomes the actively enforced value.
.Pp
The various resource control block properties are described on the
.Xr rctlblk_set_value 3C
manual page.
.Pp
Resource controls are inherited from the predecessor process or task.
One of the
.Xr exec 2
functions can modify the resource controls of a process by resetting their
histories, as noted above for insertion or deletion operations.
.Sh RETURN VALUES
.Rv -std
.Sh ERRORS
The
.Fn setrctl
and
.Fn getrctl
functions will fail if:
.Bl -tag -width Er
.It Bq Er EFAULT
The
.Fa controlname , old_blk
or
.Fa new_blk
argument points to an illegal address.
.It Bq Er EINVAL
No resource control with the given name is known to the system, or the resource
control block contains properties that are not valid for the resource control
specified.
.Pp
.Dv RCTL_USE_RECIPIENT_PID
was used to set a process scope rctl and the
process ID set by
.Xr rctlblk_set_value 3C
does not match the process ID of calling process.
.It Bq Er ENOENT
No value beyond the given resource control block exists.
.Pp
.Dv RCTL_USE_RECIPIENT_PID
was used and the process ID set by
.Xr rctlblk_set_value 3C
does not exist within the current task, project, or zone, depending on the
resource control name.
.It Bq Er ESRCH
No value matching the given resource control block was found for any of
.Dv RCTL_NEXT , RCTL_DELETE
or
.Dv RCTL_REPLACE .
.It Bq Er ENOTSUPP
The resource control requested by
.Dv RCTL_USAGE
does not support the usage operation.
.El
.Pp
The
.Fn setrctl
function will fail if:
.Bl -tag -width Er
.It Bq Er EACCES
The rctl value specified cannot be changed by the current process, including
the case where the recipient process ID does not match the calling process and
the calling process is unprivileged.
.It Bq Er EPERM
An attempt to set a system limit was attempted.
.El
.Sh EXAMPLES
Obtain the lowest enforced rctl value on the rctl limiting the number of LWPs
in a task.
.Bd -literal
#include <rctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>

\&...

rctlblk_t *rblk;

if ((rblk = malloc(rctlblk_size())) == NULL)
	err(1, "malloc");
if (getrctl("task.max-lwps", NULL, rblk, RCTL_FIRST) == -1)
	err(1, "getrctl");
printf("task.max-lwps = %llu\en", rctlblk_get_value(rblk));
.Ed
.Sh USAGE
Resource control blocks are matched on the value and privilege fields.
Resource control operations act on the first matching resource control block.
Duplicate resource control blocks are not permitted.
Multiple blocks of equal value and privilege need to be entirely deleted and
reinserted, rather than replaced, to have the correct outcome.
Resource control blocks are sorted such that all blocks with the same value
that lack the
.Dv RCTL_LOCAL_DENY
flag precede those having that flag set.
.Pp
Only one
.Dv RCPRIV_BASIC
resource control value is permitted per process per control.
Insertion of an
.Dv RCPRIV_BASIC
value will cause any existing
.Dv RCPRIV_BASIC
value owned by that process on the control to be deleted.
.Pp
The resource control facility provides the backend implementation for both
.Fn setrctl Ns / Ns Fn getrctl
and
.Fn setrlimit Ns / Ns Fn getrlimit
The facility behaves consistently when either of these interfaces is used
exclusively; when using both interfaces, the caller must be aware of the
ordering issues above, as well as the limit equivalencies described in the
following paragraph.
.Pp
The hard and soft process limits made available with
.Fn setrlimit
and
.Fn getrlimit
are mapped to the resource controls implementation.
(New process resource controls will not be made available with the rlimit
interface.)
Because of the
.Dv RCTL_INSERT
and
.Dv RCTL_DELETE
operations,
it is possible that the set of values defined on a resource control has more or
fewer than the two values defined for an rlimit.
In this case, the soft limit is the lowest priority resource control value with
the
.Dv RCTL_LOCAL_DENY
flag set, and the hard limit is the resource control value with the lowest
priority equal to or exceeding
.Dv RCPRIV_PRIVILEGED
with the
.Dv RCTL_LOCAL_DENY
flag set.
If no identifiable soft limit exists on the resource control and
.Fn setrlimit
is called, a new resource control value is created.
If a resource control does not have the global
.Dv RCTL_GLOBAL_LOWERABLE
property set, its hard limit will not allow lowering by unprivileged callers.
.Sh MT-LEVEL
.Sy Async-Signal-Safe
.Sh SEE ALSO
.Xr rctladm 1M ,
.Xr getrlimit 2 ,
.Xr errno 3C ,
.Xr rctlblk_set_value 3C ,
.Xr attributes 5 ,
.Xr resource_controls 5
