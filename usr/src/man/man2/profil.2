.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright 1989 AT&T
.\" Copyright (c) 2001, Sun Microsystems, Inc. All Rights Reserved
.\"
.Dd November 12, 2001
.Dt PROFIL 2
.Os
.Sh NAME
.Nm profil
.Nd execution time profile
.Sh SYNOPSIS
.In unistd.h
.Ft void
.Fo profil
.Fa "unsigned short *buff"
.Fa "unsigned int bufsiz"
.Fa "unsigned int offset"
.Fa "unsigned int scale"
.Fc
.Sh DESCRIPTION
The
.Fn profil
function provides CPU-use statistics by profiling the amount of CPU time
expended by a program.
The
.Fn profil
function generates the statistics by creating an execution histogram for a
current process.
The histogram is defined for a specific region of program code to be profiled,
and the identified region is logically broken up into a set of equal size
subdivisions, each of which corresponds to a count in the histogram.
With each clock tick, the current subdivision is identified and its
corresponding histogram count is incremented.
These counts establish a relative measure of how much time is being spent in
each code subdivision.
The resulting histogram counts for a profiled region can be used to identify
those functions that consume a disproportionately high percentage of CPU time.
.Pp
The
.Fa buff
argument is a
.Fa buffer
of
.Fa bufsiz
bytes in which the
histogram counts are stored in an array of
.Vt "unsigned short int" .
Once one of the counts reaches 32767
.Pq the size of a Vt "short int" ,
profiling stops and no more data is collected.
.Pp
The
.Fa offset , scale
and
.Fa bufsiz
arguments specify the region to be profiled.
.Pp
The
.Fa offset
argument is effectively the start address of the region to be profiled.
.Pp
The
.Fa scale
argument is a contraction factor that indicates how much
smaller the histogram buffer is than the region to be profiled.
More precisely,
.Fa scale
is interpreted as an unsigned 16-bit fixed-point fraction with the decimal
point implied on the left.
Its value is the reciprocal of the number of bytes in a subdivision, per byte
of histogram buffer.
Since there are two bytes per histogram counter, the effective ratio of
subdivision bytes per counter is one half the scale.
.Pp
The values of
.Fa scale
are as follows:
.Bl -dash -width Ds
.It
The maximum value of
.Fa scale ,
0xffff (approximately 1), maps subdivisions 2 bytes long to each counter.
.It
The minimum value of
.Fa scale Pq for which profiling is performed ,
0x0002 (1/32,768), maps subdivision 65,536 bytes long to each counter.
.It
The default value of
.Fa scale Pq currently used by Ql Nm cc Fl qp ,
0x4000, maps subdivisions 8 bytes long to each counter.
.El
.Pp
The values are used within the kernel as follows:  when the process is
interrupted for a clock tick, the value of
.Fa offset
is subtracted from the current value of the program counter (pc),
and the remainder is multiplied by
.Fa scale
to derive a result.
That result is used as an index into the histogram array to locate the cell to
be incremented.
Therefore, the cell count represents the number of times that the process was
executing code in the subdivision associated with that cell when the process
was interrupted.
.Pp
The value of
.Fa scale
can be computed as
.Ql Pq RATIO\ *\ 0200000L ,
where
.Va RATIO
is the desired ratio of
.Fa bufsiz
to profiled region
size, and has a value between 0 and 1.
Qualitatively speaking, the closer
.Va RATIO
is to 1, the higher the resolution of the profile information.
.Pp
The value of
.Fa bufsiz
can be computed as:
.Pp
.Dl (size_of_region_to_be_profiled * RATIO)
.Pp
Profiling is turned off by giving a
.Fa scale
value of 0 or 1, and is rendered ineffective by giving a
.Fa bufsiz
value of 0.
Profiling is turned off when one of the
.Xr exec 2
family of functions is executed, but remains on in both child and parent
processes after a
.Xr fork 2 .
Profiling is turned off if a buff update would cause a memory fault.
.Sh USAGE
The
.Xr pcsample 2
function should be used when profiling dynamically-linked programs and 64-bit
programs.
.Sh SEE ALSO
.Xr exec 2 ,
.Xr fork 2 ,
.Xr pcsample 2 ,
.Xr times 2 ,
.Xr monitor 3C ,
.Xr prof 5
.Sh NOTES
In Solaris releases prior to 2.6, calling
.Fn profil
in a multithreaded program would impact only the calling LWP;
the profile state was not inherited at LWP creation time.
To profile a multithreaded program with a global profile buffer,
each thread needed to issue a call to
.Fn profil
at threads start-up time, and each thread had to be a bound thread.
This was cumbersome and did not easily support dynamically turning profiling on
and off.
In Solaris 2.6, the
.Fn profil
system call for multithreaded processes has global impact \(em
that is, a call to
.Fn profil
impacts all LWPs/threads in the process.
This may cause applications that depend on the previous per-LWP semantic to
break, but it is expected to improve multithreaded programs that wish to turn
profiling on and off dynamically at runtime.
