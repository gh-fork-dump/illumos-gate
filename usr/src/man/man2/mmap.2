.\"
.\" Sun Microsystems, Inc. gratefully acknowledges The Open Group for
.\" permission to reproduce portions of its copyrighted documentation.
.\" Original documentation from The Open Group can be obtained online at
.\" http://www.opengroup.org/bookstore/.
.\"
.\" The Institute of Electrical and Electronics Engineers and The Open
.\" Group, have given us permission to reprint portions of their
.\" documentation.
.\"
.\" In the following statement, the phrase ``this text'' refers to portions
.\" of the system documentation.
.\"
.\" Portions of this text are reprinted and reproduced in electronic form
.\" in the SunOS Reference Manual, from IEEE Std 1003.1, 2004 Edition,
.\" Standard for Information Technology -- Portable Operating System
.\" Interface (POSIX), The Open Group Base Specifications Issue 6,
.\" Copyright (C) 2001-2004 by the Institute of Electrical and Electronics
.\" Engineers, Inc and The Open Group.  In the event of any discrepancy
.\" between these versions and the original IEEE and The Open Group
.\" Standard, the original IEEE and The Open Group Standard is the referee
.\" document.  The original Standard can be obtained online at
.\" http://www.opengroup.org/unix/online.html.
.\"
.\" This notice shall appear on any product containing this material.
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or http://www.opensolaris.org/os/licensing.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\"
.\" Copyright 1989 AT&T
.\" Portions Copyright (c) 1992, X/Open Company Limited.  All Rights Reserved.
.\" Copyright (c) 2009, Sun Microsystems, Inc.  All Rights Reserved.
.\" Copyright 2013 OmniTI Computer Consulting, Inc. All Rights Reserved.
.\" Copyright 2016 James S Blachly, MD. All Rights Reserved.
.\" Copyright 2019 Joyent, Inc.
.\"
.Dd November 19, 2019
.Dt MMAP 2
.Os
.Sh NAME
.Nm mmap
.Nd map pages of memory
.Sh SYNOPSIS
.In sys/mman.h
.Ft void *
.Fo mmap
.Fa "void *addr"
.Fa "size_t len"
.Fa "int prot"
.Fa "int flags"
.Fa "int fildes"
.Fa "off_t off"
.Fc
.Sh DESCRIPTION
The
.Fn mmap
function establishes a mapping between a process' address space and a file or
shared memory object.
The format of the call is as follows:
.Pp
.Dl Va pa = Fn mmap addr len prot flags fildes off
.Pp
The
.Fn mmap
function establishes a mapping between the address space of the process at an
address
.Va pa
for
.Fa len
bytes to the memory object represented by the file descriptor
.Fa fildes
at offset
.Fa off
for
.Fa len
bytes.
The value of
.Va pa
is a function of the
.Fa addr
argument and values of
.Fa flags ,
further described below.
A successful
.Fn mmap
call returns
.Va pa
as its result.
The address range starting at
.Va pa
and continuing for
.Fa len
bytes will be legitimate for the possible (not necessarily current) address
space of the process.
The range of bytes starting at
.Fa off
and continuing for
.Fa len
bytes will be legitimate for the possible (not necessarily current) offsets in
the file or shared memory object represented by
.Fa fildes .
.Pp
The
.Fn mmap
function allows
.Eo [
.Va pa , pa No + Fa len
.Ec )
to extend beyond the end of the object both at the time of the
.Fn mmap
and while the mapping persists, such as when the file is created prior to the
.Fn mmap
call and has no contents, or when the file is truncated.
Any reference to addresses beyond the end of the object, however, will result
in the delivery of a
.Dv SIGBUS
or
.Dv SIGSEGV
signal.
The
.Fn mmap
function cannot be used to implicitly extend the length of files.
.Pp
The mapping established by
.Fn mmap
replaces any previous mappings for those whole pages containing any part of the
address space of the process starting at pa and continuing for
.Fa len
bytes.
.Pp
If the size of the mapped file changes after the call to
.Fn mmap
as a result of some other operation on the mapped file, the effect of
references to portions of the mapped region that correspond to added or removed
portions of the file is unspecified.
.Pp
The
.Fn mmap
function is supported for regular files and shared memory objects.
Support for any other type of file is unspecified.
.Pp
The
.Fa prot
argument determines whether read, write, execute, or some
combination of accesses are permitted to the data being mapped.
The
.Fa prot
argument should be either
.Dv PROT_NONE
or the bitwise inclusive OR of one or more of the other flags in the following
table, defined in the header
.In sys/mman.h .
.Pp
.Bl -tag -compact -width "PROT_WRITE"
.It Dv PROT_READ
Data can be read.
.It Dv PROT_WRITE
Data can be written.
.It Dv PROT_EXEC
Data can be executed.
.It Dv PROT_NONE
Data cannot be accessed.
.El
.Pp
If an implementation of
.Fn mmap
for a specific platform cannot support the combination of access types
specified by
.Fa prot ,
the call to
.Fn mmap
fails.
An implementation may permit accesses other than those specified by
.Fa prot ;
however, the implementation will not permit a write to succeed where
.Dv PROT_WRITE
has not been set or permit any access where
.Dv PROT_NONE
alone has been set.
Each platform-specific implementation of
.Fn mmap
supports the following values of
.Fa prot : Dv PROT_NONE , PROT_READ , PROT_WRITE
and the inclusive OR of
.Dv PROT_READ
and
.Dv PROT_WRITE .
On some platforms, the
.Dv PROT_WRITE
protection option is implemented as
.Dv PROT_READ | PROT_WRITE
and
.Dv PROT_EXEC
as
.Dv PROT_READ | PROT_EXEC .
The file descriptor
.Fa fildes
is opened with read permission, regardless of the protection options specified.
If
.Dv PROT_WRITE
is specified, the application must have opened the file descriptor
.Fa fildes
with write permission unless
.Dv MAP_PRIVATE
is specified in the
.Fa flags
argument as described below.
.Pp
The
.Fa flags
argument provides other information about the handling of the
mapped data.
The value of
.Fa flags
is the bitwise inclusive OR of these options, defined in
.In sys/mman.h :
.Bl -tag -width "MAP_NORESERVE"
.It Dv MAP_SHARED
Changes are shared.
.It Dv MAP_PRIVATE
Changes are private.
.It Dv MAP_FIXED
Interpret
.Fa addr
exactly.
.It Dv MAP_NORESERVE
Do not reserve swap space.
.It Dv MAP_ANON
Map anonymous memory.
.It Dv MAP_ALIGN
Interpret
.Fa addr
as required alignment.
.It Dv MAP_TEXT
Map text.
.It Dv MAP_INITDATA
Map initialized data segment.
.It Dv MAP_32BIT
Map to the lower 32 bits of address space.
.It Dv MAP_FILE
Map a regular file.
This is the default behavior; specifying this flag is not required.
It is provided for compatibility with other systems and should not be included
in new code.
.El
.Pp
The
.Dv MAP_SHARED
and
.Dv MAP_PRIVATE
options describe the disposition of
write references to the underlying object.
If
.Dv MAP_SHARED
is specified,
write references will change the memory object.
If
.Dv MAP_PRIVATE
is
specified, the initial write reference will create a private copy of the memory
object page and redirect the mapping to the copy.
The private copy is not created until the first write; until then, other users
who have the object mapped
.Dv MAP_SHARED
can change the object.
Either
.Dv MAP_SHARED
or
.Dv MAP_PRIVATE
must be specified, but not both.
The mapping type is retained across
.Xr fork 2 .
.Pp
When MAP_FIXED is set in the
.Fa flags
argument, the system is informed
that the value of
.Va pa
must be
.Fa addr ,
exactly.
If
.Dv MAP_FIXED
is set,
.Fn mmap
may return
.Po Vt void * Pc Ns -1
and set
.Va errno
to
.Er EINVAL .
If a
.Dv MAP_FIXED
request is successful, the mapping established by
.Fn mmap
replaces any previous mappings for the process's
pages in the range
.Eo [
.Va pa , pa No + Fa len
.Ec ) .
The use of
.Dv MAP_FIXED
is discouraged, since it may prevent a system from making the most effective
use of its resources.
.Pp
When
.Dv MAP_FIXED
is set and the requested address is the same as previous mapping, the previous
address is unmapped and the new mapping is created on top of the old one.
.Pp
When
.Dv MAP_FIXED
is not set, the system uses
.Fa addr
to arrive at
.Va pa .
The
.Va pa
so chosen will be an area of the address space that the system deems suitable
for a mapping of
.Fa len
bytes to the file.
The
.Fn mmap
function interprets an
.Fa addr
value of 0 as granting the
system complete freedom in selecting
.Va pa ,
subject to constraints described below.
A non-zero value of
.Fa addr
is taken to be a suggestion of a process address near which the mapping should
be placed.
When the system selects a value for
.Va pa ,
it will never place a mapping at address 0, nor will it replace any extant
mapping, nor map into areas considered part of the potential data or stack
"segments".
.Pp
When
.Dv MAP_ALIGN
is set, the system is informed that the alignment of
pa must be the same as
.Fa addr .
The alignment value in
.Fa addr
must be 0 or some power of two multiple of page size as returned by
.Xr sysconf 3C .
If
.Fa addr
is 0, the system will choose a suitable alignment.
.Pp
The
.Dv MAP_NORESERVE
option specifies that no swap space be reserved for a mapping.
Without this flag, the creation of a writable
.Dv MAP_PRIVATE
mapping reserves swap space equal to the size of the mapping; when the mapping
is written into, the reserved space is employed to hold private copies of the
data.
A write into a
.Dv MAP_NORESERVE
mapping produces results which depend on the current availability of swap space
in the system.
If space is available, the write succeeds and a private copy of the written
page is created; if space is not available, the write fails and a
.Dv SIGBUS
or
.Dv SIGSEGV
signal is delivered to the writing process.
.Dv MAP_NORESERVE
mappings are inherited across
.Fn fork ;
at the time of the
.Fn fork ,
swap space is reserved in the child for all private pages that currently exist
in the parent; thereafter the child's mapping behaves as described above.
.Pp
When
.Dv MAP_ANON
is set in
.Fa flags
and
.Fa fildes
is set to -1,
.Fn mmap
provides a direct path to return anonymous pages to the caller.
This operation is equivalent to passing
.Fn mmap
an open file descriptor on
.Pa /dev/zero
with
.Dv MAP_ANON
elided from the
.Fa flags
argument.
.Pp
The
.Dv MAP_TEXT
option informs the system that the mapped region will be used primarily for
executing instructions.
This information can help the system better utilize MMU resources on some
platforms.
This flag is always passed by the dynamic linker when it maps text segments of
shared objects.
When the
.Dv MAP_TEXT
option is used for regular file mappings on some platforms, the system can
choose a mapping size larger than the page size returned by
.Xr sysconf 3C .
The specific page sizes that are used depend on the platform and the alignment
of the
.Fa addr
and
.Fa len
arguments.
Several different mapping sizes can be used to map the region with larger page
sizes used in the parts of the region that meet alignment and size requirements
for those page sizes.
.Pp
The
.Dv MAP_INITDATA
option informs the system that the mapped region is an
initialized data segment of an executable or shared object.
When the
.Dv MAP_INITDATA
option is used for regular file mappings on some platforms, the system can
choose a mapping size larger than the page size returned by
.Fn sysconf .
The
.Dv MAP_INITDATA
option should be used only by the dynamic linker for mapping initialized data
of shared objects.
.Pp
The
.Dv MAP_32BIT
option informs the system that the search space for mapping assignment should
be limited to the first 32 bits (4 GiB) of the caller's address space.
This flag is accepted in both 32-bit and 64-bit process models, but does not
alter the mapping strategy when used in a 32-bit process model.
.Pp
The
.Fa off
argument is constrained to be aligned and sized according to the value returned
by
.Fn sysconf
when passed
.Dv _SC_PAGESIZE
or
.Dv _SC_PAGE_SIZE .
When
.Dv MAP_FIXED
is specified, the
.Fa addr
argument must also meet these constraints.
The system performs mapping operations over whole pages.
Thus, while the
.Fa len
argument need not meet a size or alignment constraint, the system will include,
in any mapping operation, any partial page specified by the range
.Eo [
.Va pa , pa No + Fa len
.Ec ) .
.Pp
The system will always zero-fill any partial page at the end of an object.
Further, the system will never write out any modified portions of the last page
of an object which are beyond its end.
References to whole pages following the end of an object will result in the
delivery of a
.Dv SIGBUS
or
.Dv SIGSEGV
signal.
.Dv SIGBUS
signals may also be delivered on various file system conditions, including
quota exceeded errors.
.Pp
The
.Fn mmap
function adds an extra reference to the file associated with the file
descriptor
.Fa fildes
which is not removed by a subsequent
.Xr close 2
on that file descriptor.
This reference is removed when there are no more mappings to the file by a call
to the
.Xr munmap 2
function.
.Pp
The
.Va st_atime
field of the mapped file may be marked for update at any time between the
.Fn mmap
call and the corresponding
.Xr munmap 2
call.
The initial read or write reference to a mapped region will cause the file's
.Va st_atime
field to be marked for update if it has not already been marked for update.
.Pp
The
.Va st_ctime
and
.Va st_mtime
fields of a file that is mapped with
.Dv MAP_SHARED
and
.Dv PROT_WRITE ,
will be marked for update at some point in the interval between a write
reference to the mapped region and the next call to
.Xr msync 3C
with
.Dv MS_ASYNC
or
.Dv MS_SYNC
for that portion of the file by any process.
If there is no such call, these fields may be marked for update at any time
after a write reference if the underlying file is modified as a result.
.Pp
If the process calls
.Xr mlockall 3C
with the
.Dv MCL_FUTURE
flag, the pages mapped by all future calls to
.Fn mmap
will be locked in memory.
In this case, if not enough memory could be locked,
.Fn mmap
fails and sets
.Va errno
to
.Er EAGAIN .
.Pp
The
.Fn mmap
function aligns based on the length of the mapping.
When determining the amount of space to add to the address space,
.Fn mmap
includes two 8-KiB pages, one at each end of the mapping that are not mapped
and are therefore used as "red-zone" pages.
Attempts to reference these pages result in access violations.
.Pp
The size requested is incremented by the 16 KiB for these pages and is then
subject to rounding constraints.
The constraints for 32-bit processes are:
.Bd -literal -offset indent
If length > 4 MiB
        round to 4-MiB multiple
elseif length > 512 KiB
        round to 512-KiB multiple
else
        round to 64-KiB multiple
.Ed
.Pp
The constraints for 64-bit processes are:
.Bd -literal -offset indent
If length > 4 MiB
        round to 4-MiB multiple
else
        round to 1-MiB multiple
.Ed
.Pp
The net result is that for a 32-bit process:
.Bl -dash -width Ds
.It
If an
.Fn mmap
request is made for 4 MiB, it results in 4 MiB + 16 KiB and is rounded up to 8
MiB.
.It
If an
.Fn mmap
request is made for 512 KiB, it results in 512 KiB + 16 KiB and is rounded up
to 1 MiB.
.It
If an
.Fn mmap
request is made for 1 MiB, it results in 1 MiB + 16 KiB and is rounded up to
1.5 MiB.
.It
Each 8-KiB
.Fn mmap
request "consumes" 64 KiB of virtual address space.
.El
.Pp
To obtain maximal address space usage for a 32-bit process:
.Pp
.Bl -dash -compact
.It
Combine 8-KiB requests up to a limit of 48 KiB.
.It
Combine amounts over 48 KiB into 496-KiB chunks.
.It
Combine amounts over 496 KiB into 4080-KiB chunks.
.El
.Pp
To obtain maximal address space usage for a 64-bit process:
.Pp
.Bl -dash -compact
.It
Combine amounts \*(Lt 1008 KiB into chunks \*(Le 1008 KiB.
.It
Combine amounts over 1008 KiB into 4080-KiB chunks.
.El
.Pp
The following is the output from a 32-bit program demonstrating this:
.Bd -literal -offset indent
map 8192 bytes: 0xff390000
map 8192 bytes: 0xff380000
    64-KiB delta between starting addresses.

map 512 KiB: 0xff180000
map 512 KiB: 0xff080000
    1-MiB delta between starting addresses.

map 496 KiB: 0xff000000
map 496 KiB: 0xfef80000
    512-KiB delta between starting addresses

map 1 MiB: 0xfee00000
map 1 MiB: 0xfec80000
    536-KiB delta between starting addresses

map 1008 KiB: 0xfeb80000
map 1008 KiB: 0xfea80000
    1-MiB delta between starting addresses

map 4 MiB: 0xfe400000
map 4 MiB: 0xfdc00000
    8-MiB delta between starting addresses

map 4080 KiB: 0xfd800000
map 4080 KiB: 0xfd400000
    4-MiB delta between starting addresses
.Ed
.Pp
The following is the output of the same program compiled as a 64-bit
application:
.Bd -literal -offset indent
map 8192 bytes: 0xffffffff7f000000
map 8192 bytes: 0xffffffff7ef00000
    1-MiB delta between starting addresses

map 512 KiB: 0xffffffff7ee00000
map 512 KiB: 0xffffffff7ed00000
    1-MiB delta between starting addresses

map 496 KiB: 0xffffffff7ec00000
map 496 KiB: 0xffffffff7eb00000
    1-MiB delta between starting addresses

map 1 MiB: 0xffffffff7e900000
map 1 MiB: 0xffffffff7e700000
    2-MiB delta between starting addresses

map 1008 KiB: 0xffffffff7e600000
map 1008 KiB: 0xffffffff7e500000
    1-MiB delta between starting addresses

map 4 MiB: 0xffffffff7e000000
map 4 MiB: 0xffffffff7d800000
    8-MiB delta between starting addresses

map 4080 KiB: 0xffffffff7d400000
map 4080 KiB: 0xffffffff7d000000
    4-MiB delta between starting addresses
.Ed
.Sh RETURN VALUES
Upon successful completion, the
.Fn mmap
function returns the address at which the mapping was placed
.Pq Va pa ;
otherwise, it returns a value of
.Dv MAP_FAILED
and sets the global variable
.Va errno
to indicate the error.
The symbol
.Dv MAP_FAILED
is defined in the header
.In sys/mman.h .
No successful return from
.Fn mmap
will return the value
.Dv MAP_FAILED .
.Pp
If
.Fn mmap
fails for reasons other than
.Dv EBADF , EINVAL
or
.Dv ENOTSUP ,
some of the mappings in the address range starting at
.Fa addr
and continuing for
.Fa len
bytes may have been unmapped.
.Sh ERRORS
The
.Fn mmap
function will fail if:
.Bl -tag -width Er
.It Er EACCES
The
.Fa fildes
file descriptor is not open for read, regardless of the protection specified;
or
.Fa fildes
is not open for write and
.Dv PROT_WRITE
was specified for a
.Dv MAP_SHARED
type mapping.
.It Er EAGAIN
The mapping could not be locked in memory.
.Pp
There was insufficient room to reserve swap space for the mapping.
.It Er EBADF
The
.Fa fildes
file descriptor is not open
.Po and Dv MAP_ANON
was not specified
.Pc .
.It Er EINVAL
The arguments
.Fa addr Po if Dv MAP_FIXED
was specified
.Pc
or
.Fa off
are not multiples of the page size as returned by
.Xr sysconf 3C .
.Pp
The argument addr
.Fa addr Po if Dv MAP_ALIGN
was specified
.Pc
is not 0 or some power of two multiple of page size as returned by
.Fn sysconf .
.Pp
.Dv MAP_FIXED
and
.Dv MAP_ALIGN
are both specified.
.Pp
The field in
.Fa flags
is invalid
.Po neither Dv MAP_PRIVATE
or
.Dv MAP_SHARED
is set
.Pc .
.Pp
The argument
.Fa len
has a value equal to 0.
.Pp
.Dv MAP_ANON
was specified, but the file descriptor was not -1.
.Pp
.Dv MAP_TEXT
was specified but
.Dv PROT_EXEC
was not.
.Pp
.Dv MAP_TEXT
and
.Dv MAP_INITDATA
were both specified.
.It Er EMFILE
The number of mapped regions would exceed an implementation-dependent limit
(per process or per system).
.It Er ENODEV
The
.Fa fildes
argument refers to an object for which
.Fn mmap
is meaningless, such as a terminal.
.It Er ENOMEM
The
.Dv MAP_FIXED
option was specified and the range
.Eo [
.Va pa , pa No + Fa len
.Ec )
exceeds that allowed for the address space of a process.
.Pp
The
.Dv MAP_FIXED
option was not specified and there is insufficient room in the address space to
effect the mapping.
.Pp
The mapping could not be locked in memory, if required by
.Xr mlockall 3C ,
because it would require more space than the system is able to supply.
.Pp
The composite size of
.Fa len
plus the lengths obtained from all previous calls to
.Fn mmap
exceeds
.Dv RLIMIT_VMEM Pq see Xr getrlimit 2 .
.It Er ENOTSUP
The system does not support the combination of accesses requested in the
.Fa prot
argument.
.It Er ENXIO
Addresses in the range
.Eo [
.Va pa , pa No + Fa len
.Ec )
are invalid for the object specified by
.Fa fildes .
.Pp
The
.Dv MAP_FIXED
option was specified in
.Fa flags
and the combination of
.Fa addr , len
and
.Fa off
is invalid for the object specified by
.Fa fildes .
.It Er EOVERFLOW
The file is a regular file and the value of
.Fa off
plus
.Fa len
exceeds the offset maximum establish in the open file description associated
with
.Fa fildes .
.El
.Pp
The
.Fn mmap
function may fail if:
.Bl -tag -width Er
.It Er EAGAIN
The file to be mapped is already locked using advisory or mandatory record
locking.
See
.Xr fcntl 2 .
.El
.Sh USAGE
Use of
.Fn mmap
may reduce the amount of memory available to other memory allocation functions.
.Pp
.Dv MAP_ALIGN
is useful to assure a properly aligned value of
.Va pa
for subsequent use with
.Xr memcntl 2
and the
.Dv MC_HAT_ADVISE
command.
This is best used for large, long-lived, and heavily referenced regions.
.Dv MAP_FIXED
and
.Dv MAP_ALIGN
are always mutually-exclusive.
.Pp
Use of
.Dv MAP_FIXED
may result in unspecified behavior in further use of
.Xr brk 2 , Xr sbrk 2 , Xr malloc 3C and Xr shmat 2 .
The use of
.Dv MAP_FIXED
is discouraged, as it may prevent an implementation from making the most
effective use of resources.
.Pp
The application must ensure correct synchronization when using
.Fn mmap
in
conjunction with any other file access method, such as
.Xr read 2 and Xr write 2 ,
standard input/output, and
.Xr shmat 2 .
.Pp
The
.Fn mmap
function has a transitional interface for 64-bit file offsets.
See
.Xr lf64 5 .
.Pp
The
.Fn mmap
function allows access to resources using address space manipulations instead
of the
.Fn read Ns / Ns Fn write
interface.
Once a file is mapped, all a process has to do to access it is use the data at
the address to which the object was mapped.
.Pp
Consider the following pseudo-code:
.Bd -literal
fildes = open(...)
lseek(fildes, offset, whence)
read(fildes, buf, len)
/* use data in buf */
.Ed
.Pp
The following is a rewrite using
.Fn mmap :
.Bd -literal
fildes = open(...)
address = mmap(NULL, len, (PROT_READ | PROT_WRITE),
          MAP_PRIVATE, fildes, offset)
/* use data at address */
.Ed
.Sh INTERFACE STABILITY
.Sy Standard
.Sh MT-LEVEL
.Sy Async-Signal-Safe
.Sh SEE ALSO
.Xr close 2 ,
.Xr exec 2 ,
.Xr fcntl 2 ,
.Xr fork 2 ,
.Xr getrlimit 2 ,
.Xr memcntl 2 ,
.Xr mmapobj 2 ,
.Xr mprotect 2 ,
.Xr munmap 2 ,
.Xr shmat 2 ,
.Xr lockf 3C ,
.Xr mlockall 3C ,
.Xr msync 3C ,
.Xr plock 3C ,
.Xr sysconf 3C ,
.Xr attributes 5 ,
.Xr lf64 5 ,
.Xr standards 5 ,
.Xr null 7D ,
.Xr zero 7D
